Implement and compare the efficiency of a regular, non-balanced binary search tree to a balanced binary search tree
Course: Algorithm Analysis - CMPS 5243
Semester & Instructor: Spring 2022, Dr. TINA JOHNSON
Authors: AMULYA EJJINA(M20306671) MIHRIBAN GUNEYDAS (M20293151), DEANGELO BROWN(M20299911)

_____________________________________________________________________________________
Introduction: A data structure is in simpler words is just a method used to organize and store data in the computer to be used more efficiently. There are various types of data structures in Computer Science such as stacks, queues and linked lists that are arranged in sequential order. To use linked lists as an example these are data structures that consist of a set of nodes that are linked together by pointers. Now that we understand data structures a little better, we can discuss the types of data structures that will be focusing on in the essay are trees. These are data structures that arrange data in a hierarchal format or tree-like structure. It consists of a central node, structural nodes, and sub nodes which are connected via edges. Another way of describing the components is saying it has a root, branches, and leaves much like an actual tree. 
PURPOSE OF THE PROGRAM: The main premise of this assignment is to implement and observe the results for varying datasets using two (2) different types of “trees” mentioned earlier a balanced “tree” and non-balanced “tree”. The trees that will be experimented in this assignment are Binary Search Trees and AVL trees, and the results that are to be explored are the height of the tree, a search counter and insert counter. A binary search tree is operating just like a typical binary tree. It is a binary tree in which for every node; the left child is less than the value of the node and the right child is greater than or equal to the value of the node. Binary search tree contains three (3) algorithms which will explored throughout this experiment search, insert, and delete. The complexity for operations for BST algorithms (insert, search and delete) is O (log n). A AVL tree is the self-balancing binary search tree with the property that the difference between the height of the left and right subtree of the tree should not be more than one for any node of the tree. AVL tree contains three (3) algorithms which will explored throughout this experiment search, insert, and delete. The height will also be observed in this experiment. The height of a tree is the number of edges on the longest downward path between the root and a leaf. The complexity for operations for AVL algorithms (insert, search and delete) is O (log n). Where AVL differs from Binary Search tree is that it involves another process that are known as rotations that allow this set of data structure to be self-balancing. It calculated what is known as a balance factor and if the balance factor is anything that is 1, 0, -1 the tree rotates either left or right and recalculates the balance factors to place the tree in balance. This intern will display a new height which would the true height from the point where the tree was out of balance. The goal being to measure the and compare the efficiency between balanced “trees” and non-balanced “trees”.  The implementation of said experiment will be testing through using datasets consisting of random numbers generated ranging from 1,000 – 10,000. This will therefore see how many computations that each “tree” each tree needs to receive the desired outcome in the end.
RESULTS OF THE EXPERIMENT: Now, coming to analyzing the results of the experiment, for this experiment we used three (3) datasets using different random numbers consisting of 1,000, 4,000 and 7,000. Also, three (3) dataset tables satisfying the requirements specified in guidelines of the assignment. For our program we created the outline for the results to be displayed and ran our program and inserted results into the display. After running it, you will notice each dataset with their corresponding requirements being satisfied. The output numbers matched flawlessly with the theory that AVL tree is faster than the BST. First, comparing the heights of both the trees, though we don’t observe a vast difference between them, there definitely is a slight difference with BST having greater height. This does make sense since we are not working with huge datasets, the difference sometimes could be a minute, but the important thing is that there is a difference. Second, if we take the insert and search counters, we see a noticeable difference in these numbers, the AVL counters are 40% lesser to the BST’s. If we go in detail and see the actual numbers, we see an average of 25 in BST, whereas it is only 15 for AVL tree per element. This does pleasantly support the fact that AVL Trees are much faster in operations compared to BST. Given the sole fact that AVL being a self-balancing tree performs less meaningless computations to its counterpart. Below graph, shows that with the increase in the size of the datasets, the difference between the counters increase, when the size was low, there is not minimal difference in terms of efficiency and as the input thusly proved AVL to be much faster.
Fig 1.
THOUGHTS ON THE PROJECT: This program helped cross-verify and visualize the theory that we have on these algorithms. As a base we used the starter code for each tree that was provided in class and adjust and readjust to the designs to make the assignment interesting. The returned results satisfy the requirements and display our original theory to prove what we expected to see. This theory makes sense given how an “organized” or balanced tree would have less struggles when it comes to search and inserting values into. As this translate with real life implementation as well. It is easier to find documents in a room that is not cluttered. All in all, this was a very enjoyable project as mentioned before because it shows how many steps were need for computations of these trees which are searching and inserting.
Struggles: Stating any issues/obstacles faced, I would not say exactly obstacles, but a vast major of time would spend displaying and reverify the results by hand to see consistency with existing knowledge of how these algorithms work. Through the display and formatting time was spent in formatting of the output (Displaying them in a tabular format, watching spacing between columns... etc.) which is displayed to the terminal when the program is run. Google helped here a lot.
